## [七层网络模型](https://zhuanlan.zhihu.com/p/32059190)





## [http](https://coolshell.cn/articles/19840.html)

概述： 超文本传输协议

- HTTP/1.0

  HTTP1.0性能上有一个很大的问题，那就是每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢

- HTTP/1.1

  - keepalive

    可以设置 `keepalive` 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“**HTTP 长链接**” 或是 “**请求响应式的HTTP 持久链接**”

  - 支持pipeline网络传输

    只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的

  - 支持 Chunked Responses

  - cache control 

  - 增加协议头

  - OPTIONS

  - **在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞**

- [HTTP/2](https://juejin.cn/post/6844903984524705800)

  相关文章：https://zhuanlan.zhihu.com/p/26559480

  - HTTP/2是一个二进制协议，增加了数据传输的效率
  - HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。（多路复用）
  - **HTTP/2会压缩头**，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看[RFC 7541](https://tools.ietf.org/html/rfc7541) 附录A
  - HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。

- [HTTP/3](https://blog.csdn.net/wolfGuiDao/article/details/108729560)

  使用UDP替换TCP

  解决了哪些问题？

  - 队头阻塞问题(**`TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用`**)

  





## [https](https://zhuanlan.zhihu.com/p/26682342)

相关文章：

https://zhuanlan.zhihu.com/p/97154765

https://blog.csdn.net/oZhuZhiYuan/article/details/106650944

https://www.cnblogs.com/presleyren/p/10673456.html

- 对称加密和非对称加密

- https是用的对称加密还是非对称加密？

  答： HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段

图解

![图解](https://pic2.zhimg.com/80/v2-b3288ea1a0faf4d9823f57dfc81f7995_1440w.jpg)



**HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：**

**① 证书验证阶段：**

> 1）浏览器发起 HTTPS 请求；
> 2）服务端返回 HTTPS 证书；
> 3）客户端验证证书是否合法，如果不合法则提示告警。

**② 数据传输阶段：**

> 1）当证书验证合法后，在本地生成随机数；
> 2）通过公钥加密随机数，并把加密后的随机数传输到服务端；
> 3）服务端通过私钥对随机数进行解密；
> 4）服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。



问题：？

- **为什么数据传输是用对称加密**？

  首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。

  另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

- **浏览器怎么知道所访问的站点不是伪造的**？

  浏览器主要依靠数字证书来确认所访问的站点不是伪造的。当浏览器通过https访问站点，站点须返回数字证书。数字证书是CA机构“签发”的电子文件，其中包含使用者信息、站点公钥、颁发者（CA）信息和CA指纹等。假设数字证书是完全可信的，且其中的内容也是不可篡改的。!!!!!!!!!**浏览器首先验证数字证书中的使用者（站点）信息与所访问的站点域名是否一致，然后用数字证书中的站点公钥挑战站点服务器，只用拥有私钥的真实站点才能通过挑战。因此可以确保所访问的站点是真实的**。

  这里是为什么无法进行中间人攻击的重要原因， 因为浏览器会先验证站点是否正确， 只有拥有私钥的站点才能通过验证（怎么验证的？ 找靠谱的数字证书机构（CA）进行委托验证， 所以CA需要是权威机构）

  

- **为什么数字证书是可信的**？

  CA机构是可信的，CA本身也包含一个非对称密钥对，私钥用于“签发”的数字证书，公钥发布出去用于验证数字证书。CA使用非对称密钥配合HASH算法保证数字证书可信且不可篡改。CA将使用者信息、站点公钥、有效期等关键信息打包做HASH运算，再将HASH运算结果用CA私钥签名生成指纹。然后将以上全部信息打包成数字证书。黑客没有私钥不可以伪造证书签名，且证书的内容如果被修改，HASH结果就会改变。因此黑客不可伪造或者篡改证书，有效的数字证书是可信的。

- **浏览器怎么知道CA是可信的**？

  浏览器主要依据客户端操作系统保存的根证书列表判断CA的权威性。如上图，在Windows操作系统中，这个列表放在“受信任的根证书颁发机构存储区”中，这个列表实际上是CA机构的根证书集合，根证书包含CA机构的信息和公钥。只要是这个列表中的CA签发的证书，浏览器就认为可信。微软会动态维护根证书列表，用户需要管理员权限才能向这个列表中加入CA证书

- **为什么有些软件如Fiddler可以还原https报文**？

  Fiddler是通过中间代理的方式抓取报文，还原https报文的前提是在客户端的根证书列表下加入Fiddler生成的CA根证书。这样Fiddler就成为CA，可以伪造数字证书，伪装成服务器。但是只能用于测试，不能实现真正意义上的窃取数据。

![image-20210601001336445](/Users/admin/Library/Application Support/typora-user-images/image-20210601001336445.png)



## [websocket](https://blog.csdn.net/LL845876425/article/details/106393358)

概述： Webscoket是Web浏览器和服务器之间的一种全双工通信协议

- WS（WebSocket）与HTTP协议比较：

  相同点主要有：

  - 都是基于TCP的应用层协议；
  - 都使用Request/Response模型进行连接的建立；
  - 在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码；
  - 都可以在网络中传输数据。

  不同之处在于：

  - WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；
  - WS的连接不能通过中间人来转发，它必须是一个直接连接；
  - WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；
  - WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；
  - WS的数据帧有序。



## [tcp](https://coolshell.cn/articles/11564.html)



## [UDP](https://blog.csdn.net/aa1928992772/article/details/85240358#commentBox)