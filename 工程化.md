## [模块化机制](https://segmentfault.com/a/1190000017466120)

### CommonJs

概述

- Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**
- 记住CommonJs规范是**同步加载的**，只有加载完成，才能执行后面的操作

特点

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。
- **主要用于服务端，为什么？服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用**

基本语法

- 暴露模块：`module.exports = value`或`exports.xxx = value`
- 引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

⚠️

- CommonJs引入的对象是对象的拷贝

  证明示例：

  ```js
  // lib.js
  // lib.js
  var obj = {
    value: 1,
  };
  function increase() {
    obj.value++;
  }
  function getObjValue() {
    return obj.value;
  }
  module.exports = {
    obj,
    increase,
    getObjValue,
  };
  
  
  // main.js
  var { obj, increase, getObjValue } = require("./lib");
  console.log(obj.value); // 1
  increase();
  console.log(getObjValue()); // 2
  ```

  

- module.exports暴露出的对象在不同的地方引入，如果第一个引入的文件改变了该对象，另外一个引入的文件引入的是改变了之后的对象

- `require`： require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 特别要注意的是：    **`require`是读入并执行**， 也就是只要碰到`require`就会去执行对应文件， 然后把该文件缓存起来， 下次引入的时候直接读缓存，不去执行了， 如果要再次执行需要清除缓存



### AMD

概述

- 非同步加载
- 主要用户浏览器环境， 为什么？**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**
- 浏览器要引入AMD, 要先引入 `require.js` 库

基本语法

```js
/*****定义暴露模块*****/

//定义没有依赖的模块
define(function(){
   return 模块
})
//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})

/*******引入使用模块**********/
require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
```





### CMD

概述

- CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。
- 浏览器要引入AMD, 先引入 sea.js`` 库
- **模块的加载是异步的，模块使用时才会加载执行**

基本语法

```js
/****定义暴露模块****/
//定义没有依赖的模块
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})

//定义有依赖的模块
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})


/*******引入使用模块*****/
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```



### ES6模块化

概述

- ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
- ES6-Babel-Browserify

基本语法

```js
/*************以对象形式导出，需要具名引入******/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };

/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}


/*************以default形式导出，需要具名引入******/
// export-default.js
export default function () {
  console.log('foo');
}

// import-default.js
import customName from './export-default';
customName(); // 'foo'
```



ES6模块与CommonJs模块的差异

**① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。

示例：

```js
// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}
// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
incCounter();
console.log(counter); // 4

/*****
	ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
******/
```



**② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。

第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成